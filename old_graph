/* Your code here! */
#include "graph.h"
#include <fstream>
#include <algorithm>

#include <queue>

//graph constructor
Graph::Graph() {}

Graph::Graph(Airports airports, string filename) {
    ifstream file(filename);
    string line;
    if (file.is_open()) {
        while(getline(file, line)) {
            vector<string> temp = stringToVector(line);
            string srcId = temp[3]; // id of source airport
            string desId = temp[5]; // id of destination airport
            Airport src = airports.findAirportbyid(srcId);
            Airport des = airports.findAirportbyid(desId);
            Route r1;
            r1.src_id = srcId;
            r1.des_id = desId;
            r1.des = des;
            r1.distance = calculateDistance(src, des);
            if (map_.find(src) == map_.end()) {
                vector<Route> temp_vect;
                temp_vect.push_back(r1);
                map_.insert(pair<Airport, vector<Route>>(src, temp_vect));
            } else {
                vector<Route> & tmp = map_[src];
                if (find(tmp.begin(),tmp.end(),r1) == tmp.end()) tmp.push_back(r1);
            }
            Route r2;
            r2.src_id = desId;
            r2.des_id = srcId;
            r2.des = des;
            r2.distance = calculateDistance(des, src);
            if (map_.find(des) == map_.end()) {
                vector<Route> temp_vect;
                temp_vect.push_back(r2);
                map_.insert(pair<Airport, vector<Route>>(des, temp_vect));
            } else {
                vector<Route> & tmp = map_[des];
                if (find(tmp.begin(),tmp.end(),r2) == tmp.end()) map_[des].push_back(r2);
            }
        }
    }
}

// this function returns the vector that contains all adjacent airports of the input airport
// helper function for BFS
vector<Airport> Graph::listAdjacent(Airport input) {
    vector<Route> routes = map_[input];
    vector<Airport> output;
    for (Route r : routes) {
        output.push_back(r.des);
    }
    return output;
}

// In the project proposal, BFS was listed as an algorithmn to find the shortest path
// Rather than making BFS to find the shortest path, it will just see if the destination is reachable
// Finding shortest path means recording many routes, and for a huge graph like ours, it is gonna be very difficult
// and long for it to finish traversing. 
// We will use only Floyd-Warshall for shortest path since it is designed for that role
bool Graph::BFSTraversal(Airport src, Airport des) {
    queue<Airport> to_traverse;
    to_traverse.push(src);

    // Data structure to check if airport is visited, possibly using a map

    while(!to_traverse.empty()) {
        /* 
        add neighbors of queue front airport
        pop airport
        check if neighbor is des
        if not, push to queue

        repeat until des is found or queue ends

        */
       return false;
    }

    return true;


}

-----------------------------------------------------------

#pragma once
/* 
This is the Graph class of our project!
This graph is undirected but weighted.
we assume that if there is a route from A to B, 
then there will be a route from B to A 
*/
#include "airport.h"
#include <map>
#include <vector>
using namespace std;

// function same as Edge struct
struct Route {
    string src_id;
    string des_id;
    Airport des;
    double distance;
    bool operator==(const Route& other) const {
            return (src_id == other.src_id && des.id_ == other.des_id);
    }
};

class Graph {
    public :
    Graph();
    Graph(Airports airports, string filename);
    vector<Airport> listAdjacent(Airport);
    Route findShortestRoute(Airport src, Airport des);

    bool BFSTraversal(Airport src, Airport des);

    private :
    map<Airport, vector<Route>> map_;
};
